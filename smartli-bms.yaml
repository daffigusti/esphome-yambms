substitutions:
  name: smarli-bms
  device_description: "Monitor and control a SmartLi BMS via RS485 (Modbus)"
  tx_pin: GPIO16
  rx_pin: GPIO17
  flow_control_pin: GPIO18

esphome:
  name: ${name}
  comment: ${device_description}
  min_version: 2024.6.0
  project:
    name: "syssi.esphome-pace-bms"
    version: 2.0.0

esp32:
  board: wemos_d1_mini32
  framework:
    type: esp-idf

wifi:
  ssid: !secret wifi_ssid
  password: !secret wifi_password

ota:
  platform: esphome

logger:
  level: DEBUG

# If you use Home Assistant please remove this `mqtt` section and uncomment the `api` component!
# The native API has many advantages over MQTT: https://esphome.io/components/api.html#advantages-over-mqtt
mqtt:
  broker: !secret mqtt_host
  username: !secret mqtt_username
  password: !secret mqtt_password
  id: mqtt_client

# api:

uart:
  - id: uart_0
    baud_rate: 9600
    tx_pin: ${tx_pin}
    rx_pin: ${rx_pin}
    debug:
      direction: BOTH
      dummy_receiver: false

modbus:
  - id: modbus0
    uart_id: uart_0
    flow_control_pin: ${flow_control_pin}
    send_wait_time: 200ms

modbus_controller:
  - id: bms0
    # Slave address 0x01
    address: 214
    modbus_id: modbus0
    command_throttle: 200ms
    update_interval: 10s

binary_sensor:
  - platform: modbus_controller
    address: 0x1038
    register_type: holding
    name: "${name} BMS Charging Allowed"
    raw_encode: HEXBYTES
    lambda: |-
      uint16_t raw_value = modbus_controller::word_from_hex_str(x, 0);
      uint8_t hbyte = (raw_value >> 8) & 0xFF;  // High byte
      return !(hbyte & 0x10);  // Return true if charging is allowed

  - platform: modbus_controller
    address: 0x1038
    register_type: holding
    name: "${name} BMS Discharging Allowed"
    raw_encode: HEXBYTES
    lambda: |-
      uint16_t raw_value = modbus_controller::word_from_hex_str(x, 0);
      uint8_t hbyte = (raw_value >> 8) & 0xFF;  // High byte
      return !(hbyte & 0x20);  // Return true if discharging is allowed

sensor:
  #   1  Voltage of pack                       2 byte   R  uint16  10mV
  - platform: modbus_controller
    modbus_controller_id: bms0
    name: "${name} total battery voltage"
    address: 0
    register_type: holding
    value_type: U_WORD
    unit_of_measurement: "V"
    device_class: voltage
    state_class: measurement
    accuracy_decimals: 2
    filters:
      - multiply: 0.01

  - platform: modbus_controller
    modbus_controller_id: bms0
    name: "${name} total pack voltage"
    address: 1
    register_type: holding
    value_type: U_WORD
    unit_of_measurement: "V"
    device_class: voltage
    state_class: measurement
    accuracy_decimals: 2
    filters:
      - multiply: 0.01

  #   2  Current                               2 byte   R   int16  10mA (Positive: chargingm Negative: discharging)
  - platform: modbus_controller
    modbus_controller_id: bms0
    name: "${name} current"
    address: 2
    register_type: holding
    value_type: S_WORD
    unit_of_measurement: "A"
    device_class: current
    state_class: measurement
    accuracy_decimals: 2
    filters:
      - multiply: 0.01

  - platform: modbus_controller
    modbus_controller_id: bms0
    name: "${name} power"
    address: 0
    register_type: holding
    value_type: U_WORD
    register_count: 2
    response_size: 6
    unit_of_measurement: "W"
    device_class: power
    state_class: measurement
    accuracy_decimals: 2
    lambda: |-
      if (data.size() < 6) {
        return NAN;
      }
      float total_voltage = (uint16_t)(data[0] << 8 | data[1] << 0);
      float current = (int16_t)(data[4] << 8 | data[5] << 0);
      return current * total_voltage * 0.0001f;

  #   2  State of charge                       2 byte   R   uint8  % (0-100%)
  - platform: modbus_controller
    modbus_controller_id: bms0
    name: "${name} state of charge"
    address: 3
    id: soc_sensor
    register_type: holding
    value_type: U_WORD
    unit_of_measurement: "%"
    device_class: battery
    state_class: measurement
    accuracy_decimals: 2
    filters:
      - multiply: 1

  - platform: modbus_controller
    modbus_controller_id: bms0
    name: "${name} state of charge 2"
    address: 4
    register_type: holding
    value_type: S_WORD
    unit_of_measurement: "%"
    device_class: battery
    state_class: measurement
    accuracy_decimals: 2
    filters:
      - multiply: 1

  #   3  SOH                                   2 byte   R   uint8  % (0-100%)
  - platform: modbus_controller
    modbus_controller_id: bms0
    name: "${name} state of health"
    address: 0x1035
    register_type: holding
    value_type: U_WORD
    unit_of_measurement: "%"
    state_class: measurement
    accuracy_decimals: 2
    filters:
      - multiply: 0.01

  - platform: modbus_controller
    modbus_controller_id: bms0
    name: "${name} battery max temp"
    address: 5
    register_type: holding
    value_type: S_WORD
    unit_of_measurement: "˚C"
    device_class: temperature
    state_class: measurement
    accuracy_decimals: 2

  - platform: modbus_controller
    modbus_controller_id: bms0
    name: "${name} battery min temp"
    address: 6
    register_type: holding
    value_type: S_WORD
    unit_of_measurement: "˚C"
    device_class: temperature
    state_class: measurement
    accuracy_decimals: 2

  - platform: modbus_controller
    modbus_controller_id: bms0
    name: "${name} mos temperature"
    address: 0x104c
    register_type: holding
    value_type: S_WORD
    unit_of_measurement: "˚C"
    device_class: temperature
    state_class: measurement
    accuracy_decimals: 2

  - platform: modbus_controller
    modbus_controller_id: bms0
    name: "${name} cell voltage 1"
    id: smarli_bms_cell_voltage_1
    address: 34
    register_type: holding
    value_type: U_WORD
    unit_of_measurement: "V"
    state_class: measurement
    accuracy_decimals: 3
    filters:
      - multiply: 0.001

  - platform: modbus_controller
    modbus_controller_id: bms0
    name: "${name} cell voltage 2"
    id: smarli_bms_cell_voltage_2
    address: 35
    register_type: holding
    value_type: U_WORD
    unit_of_measurement: "V"
    state_class: measurement
    accuracy_decimals: 3
    filters:
      - multiply: 0.001

  - platform: modbus_controller
    modbus_controller_id: bms0
    name: "${name} cell voltage 3"
    id: smarli_bms_cell_voltage_3
    address: 36
    register_type: holding
    value_type: U_WORD
    unit_of_measurement: "V"
    state_class: measurement
    accuracy_decimals: 3
    filters:
      - multiply: 0.001

  - platform: modbus_controller
    modbus_controller_id: bms0
    name: "${name} cell voltage 4"
    id: smarli_bms_cell_voltage_4
    address: 37
    register_type: holding
    value_type: U_WORD
    unit_of_measurement: "V"
    state_class: measurement
    accuracy_decimals: 3
    filters:
      - multiply: 0.001
  - platform: modbus_controller
    modbus_controller_id: bms0
    name: "${name} cell voltage 5"
    id: smarli_bms_cell_voltage_5
    address: 38
    register_type: holding
    value_type: U_WORD
    unit_of_measurement: "V"
    state_class: measurement
    accuracy_decimals: 3
    filters:
      - multiply: 0.001

  - platform: modbus_controller
    modbus_controller_id: bms0
    name: "${name} cell voltage 6"
    id: smarli_bms_cell_voltage_6
    address: 39
    register_type: holding
    value_type: U_WORD
    unit_of_measurement: "V"
    state_class: measurement
    accuracy_decimals: 3
    filters:
      - multiply: 0.001

  - platform: modbus_controller
    modbus_controller_id: bms0
    name: "${name} cell voltage 7"
    id: smarli_bms_cell_voltage_7
    address: 40
    register_type: holding
    value_type: U_WORD
    unit_of_measurement: "V"
    state_class: measurement
    accuracy_decimals: 3
    filters:
      - multiply: 0.001

  - platform: modbus_controller
    modbus_controller_id: bms0
    name: "${name} cell voltage 8"
    id: smarli_bms_cell_voltage_8
    address: 41
    register_type: holding
    value_type: U_WORD
    unit_of_measurement: "V"
    state_class: measurement
    accuracy_decimals: 3
    filters:
      - multiply: 0.001
  - platform: modbus_controller
    modbus_controller_id: bms0
    name: "${name} cell voltage 9"
    id: smarli_bms_cell_voltage_9
    address: 42
    register_type: holding
    value_type: U_WORD
    unit_of_measurement: "V"
    state_class: measurement
    accuracy_decimals: 3
    filters:
      - multiply: 0.001

  - platform: modbus_controller
    modbus_controller_id: bms0
    name: "${name} cell voltage 10"
    id: smarli_bms_cell_voltage_10
    address: 43
    register_type: holding
    value_type: U_WORD
    unit_of_measurement: "V"
    state_class: measurement
    accuracy_decimals: 3
    filters:
      - multiply: 0.001

  - platform: modbus_controller
    modbus_controller_id: bms0
    name: "${name} cell voltage 11"
    id: smarli_bms_cell_voltage_11
    address: 44
    register_type: holding
    value_type: U_WORD
    unit_of_measurement: "V"
    state_class: measurement
    accuracy_decimals: 3
    filters:
      - multiply: 0.001

  - platform: modbus_controller
    modbus_controller_id: bms0
    name: "${name} cell voltage 12"
    id: smarli_bms_cell_voltage_12
    address: 45
    register_type: holding
    value_type: U_WORD
    unit_of_measurement: "V"
    state_class: measurement
    accuracy_decimals: 3
    filters:
      - multiply: 0.001
  - platform: modbus_controller
    modbus_controller_id: bms0
    name: "${name} cell voltage 13"
    id: smarli_bms_cell_voltage_13
    address: 46
    register_type: holding
    value_type: U_WORD
    unit_of_measurement: "V"
    state_class: measurement
    accuracy_decimals: 3
    filters:
      - multiply: 0.001

  - platform: modbus_controller
    modbus_controller_id: bms0
    name: "${name} cell voltage 14"
    id: smarli_bms_cell_voltage_14
    address: 47
    register_type: holding
    value_type: U_WORD
    unit_of_measurement: "V"
    state_class: measurement
    accuracy_decimals: 3
    filters:
      - multiply: 0.001

  - platform: modbus_controller
    modbus_controller_id: bms0
    name: "${name} cell voltage 15"
    id: smarli_bms_cell_voltage_15
    address: 48
    register_type: holding
    value_type: U_WORD
    unit_of_measurement: "V"
    state_class: measurement
    accuracy_decimals: 3
    filters:
      - multiply: 0.001

  # Add a new template sensor for minimum cell voltage
  - platform: template
    name: "${name} min cell voltage"
    unit_of_measurement: "V"
    device_class: voltage
    state_class: measurement
    accuracy_decimals: 3
    lambda: |-
      std::vector<float> cell_voltages;
      std::vector<Sensor*> sensors = {
        id(smarli_bms_cell_voltage_1),
        id(smarli_bms_cell_voltage_2),
        id(smarli_bms_cell_voltage_3),
        id(smarli_bms_cell_voltage_4),
        id(smarli_bms_cell_voltage_5),
        id(smarli_bms_cell_voltage_6),
        id(smarli_bms_cell_voltage_7),
        id(smarli_bms_cell_voltage_8),
        id(smarli_bms_cell_voltage_9),
        id(smarli_bms_cell_voltage_10),
        id(smarli_bms_cell_voltage_11),
        id(smarli_bms_cell_voltage_12),
        id(smarli_bms_cell_voltage_13),
        id(smarli_bms_cell_voltage_14),
        id(smarli_bms_cell_voltage_15)
      };

      for (auto sensor : sensors) {
        if (sensor != nullptr && sensor->has_state()) {
          cell_voltages.push_back(sensor->state);
        }
      }

      if (!cell_voltages.empty()) {
        return *std::min_element(cell_voltages.begin(), cell_voltages.end());
      } else {
        return 0.0f; // Return a default value if no sensors are available
      }

  - platform: template
    id: smarli_bms_max_cell_voltage
    name: "smarli-bms max cell voltage"
    unit_of_measurement: "V"
    device_class: voltage
    state_class: measurement
    accuracy_decimals: 3
    lambda: |-
      std::vector<float> cell_voltages;
      std::vector<Sensor*> sensors = {
        id(smarli_bms_cell_voltage_1),
        id(smarli_bms_cell_voltage_2),
        id(smarli_bms_cell_voltage_3),
        id(smarli_bms_cell_voltage_4),
        id(smarli_bms_cell_voltage_5),
        id(smarli_bms_cell_voltage_6),
        id(smarli_bms_cell_voltage_7),
        id(smarli_bms_cell_voltage_8),
        id(smarli_bms_cell_voltage_9),
        id(smarli_bms_cell_voltage_10),
        id(smarli_bms_cell_voltage_11),
        id(smarli_bms_cell_voltage_12),
        id(smarli_bms_cell_voltage_13),
        id(smarli_bms_cell_voltage_14),
        id(smarli_bms_cell_voltage_15)
      };

      for (auto sensor : sensors) {
        if (sensor != nullptr && sensor->has_state()) {
          cell_voltages.push_back(sensor->state);
        }
      }

      if (!cell_voltages.empty()) {
        return *std::max_element(cell_voltages.begin(), cell_voltages.end());
      } else {
        return 0.0f; // Default value if no sensors are available
      }

  - platform: template
    name: "${name} min cell number"
    accuracy_decimals: 0
    lambda: |-
      std::vector<std::pair<float, int>> cell_voltages;
      std::vector<Sensor*> sensors = {
        id(smarli_bms_cell_voltage_1),
        id(smarli_bms_cell_voltage_2),
        id(smarli_bms_cell_voltage_3),
        id(smarli_bms_cell_voltage_4),
        id(smarli_bms_cell_voltage_5),
        id(smarli_bms_cell_voltage_6),
        id(smarli_bms_cell_voltage_7),
        id(smarli_bms_cell_voltage_8),
        id(smarli_bms_cell_voltage_9),
        id(smarli_bms_cell_voltage_10),
        id(smarli_bms_cell_voltage_11),
        id(smarli_bms_cell_voltage_12),
        id(smarli_bms_cell_voltage_13),
        id(smarli_bms_cell_voltage_14),
        id(smarli_bms_cell_voltage_15)
      };

      for (int i = 0; i < sensors.size(); i++) {
        if (sensors[i] != nullptr && sensors[i]->has_state()) {
          cell_voltages.emplace_back(sensors[i]->state, i + 1);
        }
      }

      if (!cell_voltages.empty()) {
        auto min_element = std::min_element(cell_voltages.begin(), cell_voltages.end());
        return min_element->second;
      } else {
        return 0; // Return a default value if no sensors are available
      }

  - platform: template
    name: "${name} max cell number"
    accuracy_decimals: 0
    lambda: |-
      std::vector<std::pair<float, int>> cell_voltages;
      std::vector<Sensor*> sensors = {
        id(smarli_bms_cell_voltage_1),
        id(smarli_bms_cell_voltage_2),
        id(smarli_bms_cell_voltage_3),
        id(smarli_bms_cell_voltage_4),
        id(smarli_bms_cell_voltage_5),
        id(smarli_bms_cell_voltage_6),
        id(smarli_bms_cell_voltage_7),
        id(smarli_bms_cell_voltage_8),
        id(smarli_bms_cell_voltage_9),
        id(smarli_bms_cell_voltage_10),
        id(smarli_bms_cell_voltage_11),
        id(smarli_bms_cell_voltage_12),
        id(smarli_bms_cell_voltage_13),
        id(smarli_bms_cell_voltage_14),
        id(smarli_bms_cell_voltage_15)
      };

      for (int i = 0; i < sensors.size(); i++) {
        if (sensors[i] != nullptr && sensors[i]->has_state()) {
          cell_voltages.emplace_back(sensors[i]->state, i + 1);
        }
      }

      if (!cell_voltages.empty()) {
        auto max_element = std::max_element(cell_voltages.begin(), cell_voltages.end());
        return max_element->second;
      } else {
        return 0; // Default value if no sensors are available
      }
  - platform: modbus_controller
    modbus_controller_id: bms0
    name: "${name} discharge times"
    address: 67
    register_type: holding
    value_type: U_WORD
    accuracy_decimals: 0

  - platform: modbus_controller
    modbus_controller_id: bms0
    name: "${name} discharges"
    address: 69
    register_type: holding
    value_type: U_WORD
    accuracy_decimals: 0

  - platform: modbus_controller
    modbus_controller_id: bms0
    name: "${name} battery cycles"
    address: 0x1033
    register_type: holding
    value_type: U_WORD
    state_class: total_increasing
    accuracy_decimals: 0

  - platform: modbus_controller
    modbus_controller_id: bms0
    name: "${name} full battery capacity"
    address: 0x1032
    register_type: holding
    value_type: U_WORD
    unit_of_measurement: "Ah"
    device_class: current
    state_class: measurement
    accuracy_decimals: 2
    filters:
      - multiply: 0.01

  - platform: modbus_controller
    modbus_controller_id: bms0
    name: "${name} TCell1"
    address: 0x0012
    register_type: holding
    value_type: S_WORD
    unit_of_measurement: "˚C"
    device_class: temperature
    state_class: measurement
    accuracy_decimals: 2

  - platform: modbus_controller
    modbus_controller_id: bms0
    name: "${name} TCell2"
    address: 0x0013
    register_type: holding
    value_type: S_WORD
    unit_of_measurement: "˚C"
    device_class: temperature
    state_class: measurement
    accuracy_decimals: 2

  - platform: modbus_controller
    modbus_controller_id: bms0
    name: "${name} TCell3"
    address: 0x0014
    register_type: holding
    value_type: S_WORD
    unit_of_measurement: "˚C"
    device_class: temperature
    state_class: measurement
    accuracy_decimals: 2

  - platform: modbus_controller
    modbus_controller_id: bms0
    name: "${name} TCell4"
    address: 0x0015
    register_type: holding
    value_type: S_WORD
    unit_of_measurement: "˚C"
    device_class: temperature
    state_class: measurement
    accuracy_decimals: 2

  - platform: modbus_controller
    modbus_controller_id: bms0
    name: "${name} TCell5"
    address: 0x0016
    register_type: holding
    value_type: S_WORD
    unit_of_measurement: "˚C"
    device_class: temperature
    state_class: measurement
    accuracy_decimals: 2

  - platform: modbus_controller
    modbus_controller_id: bms0
    name: "${name} TCell6"
    address: 0x0017
    register_type: holding
    value_type: S_WORD
    unit_of_measurement: "˚C"
    device_class: temperature
    state_class: measurement
    accuracy_decimals: 2

  - platform: modbus_controller
    modbus_controller_id: bms0
    name: "${name} TCell7"
    address: 0x0018
    register_type: holding
    value_type: S_WORD
    unit_of_measurement: "˚C"
    device_class: temperature
    state_class: measurement
    accuracy_decimals: 2

  - platform: modbus_controller
    modbus_controller_id: bms0
    name: "${name} TCell8"
    address: 0x0019
    register_type: holding
    value_type: S_WORD
    unit_of_measurement: "˚C"
    device_class: temperature
    state_class: measurement
    accuracy_decimals: 2

  - platform: modbus_controller
    modbus_controller_id: bms0
    name: "${name} TCell9"
    address: 0x001A
    register_type: holding
    value_type: S_WORD
    unit_of_measurement: "˚C"
    device_class: temperature
    state_class: measurement
    accuracy_decimals: 2

  - platform: modbus_controller
    modbus_controller_id: bms0
    name: "${name} TCell10"
    address: 0x001B
    register_type: holding
    value_type: S_WORD
    unit_of_measurement: "˚C"
    device_class: temperature
    state_class: measurement
    accuracy_decimals: 2

  - platform: modbus_controller
    modbus_controller_id: bms0
    name: "${name} TCell11"
    address: 0x001C
    register_type: holding
    value_type: S_WORD
    unit_of_measurement: "˚C"
    device_class: temperature
    state_class: measurement
    accuracy_decimals: 2

  - platform: modbus_controller
    modbus_controller_id: bms0
    name: "${name} TCell12"
    address: 0x001D
    register_type: holding
    value_type: S_WORD
    unit_of_measurement: "˚C"
    device_class: temperature
    state_class: measurement
    accuracy_decimals: 2

  - platform: modbus_controller
    modbus_controller_id: bms0
    name: "${name} TCell13"
    address: 0x001E
    register_type: holding
    value_type: S_WORD
    unit_of_measurement: "˚C"
    device_class: temperature
    state_class: measurement
    accuracy_decimals: 2

  - platform: modbus_controller
    modbus_controller_id: bms0
    name: "${name} TCell14"
    address: 0x001F
    register_type: holding
    value_type: S_WORD
    unit_of_measurement: "˚C"
    device_class: temperature
    state_class: measurement
    accuracy_decimals: 2

  - platform: modbus_controller
    modbus_controller_id: bms0
    name: "${name} TCell15"
    address: 0x0020
    register_type: holding
    value_type: S_WORD
    unit_of_measurement: "˚C"
    device_class: temperature
    state_class: measurement
    accuracy_decimals: 2

  - platform: modbus_controller
    modbus_controller_id: bms0
    name: "${name} TCell16"
    address: 0x0021
    register_type: holding
    value_type: S_WORD
    unit_of_measurement: "˚C"
    device_class: temperature
    state_class: measurement
    accuracy_decimals: 2

  - platform: modbus_controller
    modbus_controller_id: bms0
    name: "${name} Number of Cells"
    address: 0x010f
    register_type: holding
    value_type: S_WORD
    accuracy_decimals: 1

  - platform: modbus_controller
    modbus_controller_id: bms0
    name: "${name} Depth of Discharge"
    address: 0x1015
    register_type: holding
    value_type: U_WORD
    unit_of_measurement: "%"
    accuracy_decimals: 0
    filters:
      - multiply: 0.01

  - platform: modbus_controller
    modbus_controller_id: bms0
    name: "${name} Ibus"
    address: 0x1016
    register_type: holding
    value_type: S_WORD
    unit_of_measurement: "A"
    accuracy_decimals: 0
    filters:
      - multiply: 0.01

  - platform: modbus_controller
    modbus_controller_id: bms0
    name: "${name} Ibat"
    address: 0x1016
    register_type: holding
    value_type: S_WORD
    unit_of_measurement: "I"
    accuracy_decimals: 0
    filters:
      - multiply: 0.01
  - platform: modbus_controller
    name: "${name} Total Charge Capacity"
    address: 0x1040
    register_type: holding
    unit_of_measurement: "Ah"
    value_type: U_DWORD
    accuracy_decimals: 0
    filters:
      - multiply: 1
    device_class: energy
    state_class: total_increasing

  - platform: modbus_controller
    name: "${name} Total Capacity"
    address: 0x1042
    register_type: holding
    unit_of_measurement: "Ah"
    value_type: U_DWORD
    accuracy_decimals: 0
    filters:
      - multiply: 1
    device_class: energy
    state_class: measurement
  - platform: template
    name: "${name} Remaining Capacity"
    unit_of_measurement: "Ah"
    device_class: energy
    state_class: measurement
    accuracy_decimals: 1
    lambda: |-
      auto soc = id(soc_sensor).state;
      if (!std::isnan(soc)) {
        return soc * 100.0 / 100.0;  // 100.0 is the full capacity in Ah
      } else {
        return {};
      }

text_sensor:
  - platform: modbus_controller
    address: 0x1016
    register_type: holding
    name: "${name} Mode Control"
    raw_encode: HEXBYTES
    lambda: |-
      uint16_t raw_value = modbus_controller::word_from_hex_str(x, 0);
      switch (raw_value) {
        case 0x0010:
          return std::string("Power Management");
        case 0x0303:
          return std::string("Battery Characteristic Discharge Mode");
        case 0x0505:
          return std::string("Maintenance");
        case 0x0606:
          return std::string("Production Test");
        case 0x0707:
          return std::string("Self-managed Constant Voltage Discharge");
        default:
          return std::string("Unknown Mode");
      }
      return x;
  - platform: modbus_controller
    address: 0x1037
    register_type: holding
    name: "${name} BMS Alarm Status 1"
    raw_encode: HEXBYTES
    lambda: |-
      uint16_t raw_value = modbus_controller::word_from_hex_str(x, 0);
      uint8_t hbyte = (raw_value >> 8) & 0xFF;  // High byte
      uint8_t lbyte = raw_value & 0xFF;         // Low byte

      std::vector<std::string> alarms;

      if (hbyte & 0x04) alarms.push_back("Cell voltage is too low");
      if (hbyte & 0x08) alarms.push_back("Voltage sampling disconnection");
      if (hbyte & 0x10) alarms.push_back("Charging MOS is damaged");
      if (hbyte & 0x20) alarms.push_back("Discharge MOS damage");
      if (hbyte & 0x40) alarms.push_back("Voltage sampling element is damaged");

      if (alarms.empty()) {
        return std::string("No alarms");
      } else {
        std::string result = "Alarms: ";
        for (size_t i = 0; i < alarms.size(); ++i) {
          result += alarms[i];
          if (i < alarms.size() - 1) {
            result += ", ";
          }
        }
        return result;
      }
      return x;

  - platform: modbus_controller
    address: 0x1038
    register_type: holding
    name: "${name} BMS Alarm Status 2"
    raw_encode: HEXBYTES
    lambda: |-
      uint16_t raw_value = modbus_controller::word_from_hex_str(x, 0);
      uint8_t hbyte = (raw_value >> 8) & 0xFF;  // High byte
      uint8_t lbyte = raw_value & 0xFF;         // Low byte

      std::vector<std::string> alarms;
      std::vector<std::string> states;

      // High byte alarms
      if (hbyte & 0x01) alarms.push_back("Discharge overtemperature protection");
      if (hbyte & 0x02) alarms.push_back("Discharge undertemperature protection");
      if (hbyte & 0x04) alarms.push_back("Overall Overvoltage Protection");
      if (hbyte & 0x08) alarms.push_back("Startup failed");

      // Charge MOS state
      states.push_back((hbyte & 0x10) ? "Charge MOS off" : "Charge MOS on");

      // Discharge MOS state
      states.push_back((hbyte & 0x20) ? "Discharge MOS off" : "Discharge MOS on");

      // Low byte alarms and states
      if (lbyte & 0x01) states.push_back("Charging");
      if (lbyte & 0x02) states.push_back("Discharging");
      if (lbyte & 0x04) alarms.push_back("Short circuit protection");
      if (lbyte & 0x10) alarms.push_back("Overvoltage protection (not resolved)");
      if (lbyte & 0x20) alarms.push_back("Undervoltage protection (not resolved)");
      if (lbyte & 0x40) alarms.push_back("Charging over temperature protection");
      if (lbyte & 0x80) alarms.push_back("Charging under temperature protection");

      std::string result;
      if (!states.empty()) {
        result += "States: ";
        for (size_t i = 0; i < states.size(); ++i) {
          result += states[i];
          if (i < states.size() - 1) {
            result += ", ";
          }
        }
      }

      if (!alarms.empty()) {
        if (!result.empty()) result += "; ";
        result += "Alarms: ";
        for (size_t i = 0; i < alarms.size(); ++i) {
          result += alarms[i];
          if (i < alarms.size() - 1) {
            result += ", ";
          }
        }
      }

      return result.empty() ? std::string("No alarms or notable states") : result;
  - platform: modbus_controller
    address: 0x1039
    register_type: holding
    name: "${name} BMS Alarm Status 3"
    raw_encode: HEXBYTES
    lambda: |-
      uint16_t raw_value = modbus_controller::word_from_hex_str(x, 0);
      uint8_t hbyte = (raw_value >> 8) & 0xFF;  // High byte
      uint8_t lbyte = raw_value & 0xFF;         // Low byte

      std::vector<std::string> alarms;
      std::vector<std::string> states;

      // High byte alarms and states
      if (hbyte & 0x01) alarms.push_back("Environmental low temperature protection");
      if (hbyte & 0x02) alarms.push_back("Environmental high temperature protection");
      if (hbyte & 0x80) states.push_back("Fan on");

      // Low byte alarms and states
      if (lbyte & 0x01) states.push_back("Force charging MOS on");
      if (lbyte & 0x02) states.push_back("Force charging MOS off");
      if (lbyte & 0x04) states.push_back("Forced discharge MOS on");
      if (lbyte & 0x08) states.push_back("Forced discharge MOS off");
      if (lbyte & 0x10) states.push_back("Heating pad on");
      if (lbyte & 0x20) alarms.push_back("MOSFET over temperature protection");
      if (lbyte & 0x40) alarms.push_back("MOSFET low temperature protection");
      if (lbyte & 0x80) alarms.push_back("Charging temperature too low");

      std::string result;
      if (!states.empty()) {
        result += "States: ";
        for (size_t i = 0; i < states.size(); ++i) {
          result += states[i];
          if (i < states.size() - 1) {
            result += ", ";
          }
        }
      }

      if (!alarms.empty()) {
        if (!result.empty()) result += "; ";
        result += "Alarms: ";
        for (size_t i = 0; i < alarms.size(); ++i) {
          result += alarms[i];
          if (i < alarms.size() - 1) {
            result += ", ";
          }
        }
      }

      return result.empty() ? std::string("No alarms or notable states") : result;
  - platform: modbus_controller
    address: 0x103c
    register_type: holding
    name: "${name} BMS Protection Status"
    raw_encode: HEXBYTES
    lambda: |-
      uint16_t raw_value = modbus_controller::word_from_hex_str(x, 0);
      uint8_t hbyte = (raw_value >> 8) & 0xFF;  // High byte
      uint8_t lbyte = raw_value & 0xFF;         // Low byte

      std::vector<std::string> protections;

      // High byte protections
      if (hbyte & 0x20) protections.push_back("Full charge protection");

      // Low byte protections
      if (lbyte & 0x01) protections.push_back("Cell overvoltage protection");
      if (lbyte & 0x02) protections.push_back("Overall overvoltage protection");
      if (lbyte & 0x04) protections.push_back("Cell undervoltage protection");
      if (lbyte & 0x08) protections.push_back("Overall undervoltage protection");
      if (lbyte & 0x10) protections.push_back("Charging overcurrent 1 protection");
      if (lbyte & 0x20) protections.push_back("Charging overcurrent 2 protection");
      if (lbyte & 0x40) protections.push_back("Discharge overcurrent 1 protection");
      if (lbyte & 0x80) protections.push_back("Discharge overcurrent 2 protection");

      if (protections.empty()) {
        return std::string("No active protections");
      } else {
        std::string result = "Active protections: ";
        for (size_t i = 0; i < protections.size(); ++i) {
          result += protections[i];
          if (i < protections.size() - 1) {
            result += ", ";
          }
        }
        return result;
      }
  - platform: modbus_controller
    address: 0x103d
    register_type: holding
    name: "${name} BMS Operating Status"
    raw_encode: HEXBYTES
    lambda: |-
      uint16_t raw_value = modbus_controller::word_from_hex_str(x, 0);
      uint8_t hbyte = (raw_value >> 8) & 0xFF;  // High byte
      uint8_t lbyte = raw_value & 0xFF;         // Low byte

      std::string discharge_mode;
      switch (hbyte) {
        case 1:
          discharge_mode = "Power management constant voltage discharge";
          break;
        case 2:
          discharge_mode = "Battery characteristic discharge mode";
          break;
        case 3:
          discharge_mode = "Self-managed constant voltage discharge (self-following)";
          break;
        default:
          discharge_mode = "Unknown discharge mode";
      }

      std::string running_status;
      switch (lbyte) {
        case 1: running_status = "Precharge"; break;
        case 2: running_status = "Through charging"; break;
        case 3: running_status = "Through discharging"; break;
        case 4: running_status = "BUCK charging"; break;
        case 5: running_status = "BOOST charging"; break;
        case 6: running_status = "BUCK discharge"; break;
        case 7: running_status = "BOOST discharge"; break;
        case 8: running_status = "Standby (normal, no current)"; break;
        case 9: running_status = "Alarm"; break;
        case 10: running_status = "Protection shutdown"; break;
        case 11: running_status = "Fault shutdown"; break;
        case 12: running_status = "Maintenance mode"; break;
        case 13: running_status = "Test mode"; break;
        case 14: running_status = "Sleep"; break;
        default: running_status = "Unknown status";
      }

      return "Discharge mode: " + discharge_mode + "; Running status: " + running_status;

  - platform: modbus_controller
    address: 0x1038
    register_type: holding
    name: "${name} BMS Status"
    raw_encode: HEXBYTES
    lambda: |-
      uint16_t raw_value = modbus_controller::word_from_hex_str(x, 0);
      uint8_t hbyte = (raw_value >> 8) & 0xFF;  // High byte
      uint8_t lbyte = raw_value & 0xFF;         // Low byte

      std::vector<std::string> states;

      // Charge MOS state
      bool charge_allowed = !(hbyte & 0x10);
      states.push_back(charge_allowed ? "Charge MOS on (charging allowed)" : "Charge MOS off (charging not allowed)");

      // Discharge MOS state
      bool discharge_allowed = !(hbyte & 0x20);
      states.push_back(discharge_allowed ? "Discharge MOS on (discharging allowed)" : "Discharge MOS off (discharging not allowed)");

      // Add overall charge and discharge status
      states.push_back(charge_allowed ? "Charging allowed" : "Charging not allowed");
      states.push_back(discharge_allowed ? "Discharging allowed" : "Discharging not allowed");

      return states;
