substitutions:
  name: smarli-bms
  device_description: "Monitor and control a SmartLi BMS via RS485 (Modbus)"
  tx_pin: GPIO16
  rx_pin: GPIO17
  flow_control_pin: GPIO18

esphome:
  name: ${name}
  comment: ${device_description}
  min_version: 2024.6.0
  project:
    name: "syssi.esphome-pace-bms"
    version: 2.0.0

esp32:
  board: wemos_d1_mini32
  framework:
    type: esp-idf

wifi:
  ssid: !secret wifi_ssid
  password: !secret wifi_password

ota:
  platform: esphome

logger:
  level: DEBUG

# If you use Home Assistant please remove this `mqtt` section and uncomment the `api` component!
# The native API has many advantages over MQTT: https://esphome.io/components/api.html#advantages-over-mqtt
mqtt:
  broker: !secret mqtt_host
  username: !secret mqtt_username
  password: !secret mqtt_password
  id: mqtt_client

# api:

uart:
  - id: uart_0
    baud_rate: 9600
    tx_pin: ${tx_pin}
    rx_pin: ${rx_pin}
    debug:
      direction: BOTH
      dummy_receiver: false

modbus:
  - id: modbus0
    uart_id: uart_0
    flow_control_pin: ${flow_control_pin}
    send_wait_time: 200ms

modbus_controller:
  - id: bms0
    # Slave address 0x01
    address: 214
    modbus_id: modbus0
    command_throttle: 200ms
    update_interval: 10s

sensor:
  #   1  Voltage of pack                       2 byte   R  uint16  10mV
  - platform: modbus_controller
    modbus_controller_id: bms0
    name: "${name} total battery voltage"
    address: 0
    register_type: holding
    value_type: U_WORD
    unit_of_measurement: "V"
    device_class: voltage
    state_class: measurement
    accuracy_decimals: 2
    filters:
      - multiply: 0.01

  - platform: modbus_controller
    modbus_controller_id: bms0
    name: "${name} total pack voltage"
    address: 1
    register_type: holding
    value_type: U_WORD
    unit_of_measurement: "V"
    device_class: voltage
    state_class: measurement
    accuracy_decimals: 2
    filters:
      - multiply: 0.01

  #   2  Current                               2 byte   R   int16  10mA (Positive: chargingm Negative: discharging)
  - platform: modbus_controller
    modbus_controller_id: bms0
    name: "${name} current"
    address: 2
    register_type: holding
    value_type: S_WORD
    unit_of_measurement: "A"
    device_class: current
    state_class: measurement
    accuracy_decimals: 2
    filters:
      - multiply: 0.01

  - platform: modbus_controller
    modbus_controller_id: bms0
    name: "${name} power"
    address: 0
    register_type: holding
    value_type: U_WORD
    register_count: 2
    response_size: 6
    unit_of_measurement: "W"
    device_class: power
    state_class: measurement
    accuracy_decimals: 2
    lambda: |-
      if (data.size() < 6) {
        return NAN;
      }
      float total_voltage = (uint16_t)(data[0] << 8 | data[1] << 0);
      float current = (int16_t)(data[4] << 8 | data[5] << 0);
      return current * total_voltage * 0.0001f;

  #   2  State of charge                       2 byte   R   uint8  % (0-100%)
  - platform: modbus_controller
    modbus_controller_id: bms0
    name: "${name} state of charge"
    address: 0x1035
    register_type: holding
    value_type: U_WORD
    unit_of_measurement: "%"
    device_class: battery
    state_class: measurement
    accuracy_decimals: 2
    filters:
      - multiply: 0.01

  #   3  SOH                                   2 byte   R   uint8  % (0-100%)
  - platform: modbus_controller
    modbus_controller_id: bms0
    name: "${name} state of health"
    address: 0x1035
    register_type: holding
    value_type: U_WORD
    unit_of_measurement: "%"
    state_class: measurement
    accuracy_decimals: 2
    filters:
      - multiply: 0.01

  - platform: modbus_controller
    modbus_controller_id: bms0
    name: "${name} battery max temp"
    address: 5
    register_type: holding
    value_type: S_WORD
    unit_of_measurement: "˚C"
    device_class: temperature
    state_class: measurement
    accuracy_decimals: 2

  - platform: modbus_controller
    modbus_controller_id: bms0
    name: "${name} battery min temp"
    address: 6
    register_type: holding
    value_type: S_WORD
    unit_of_measurement: "˚C"
    device_class: temperature
    state_class: measurement
    accuracy_decimals: 2

  - platform: modbus_controller
    modbus_controller_id: bms0
    name: "${name} mos temperature"
    address: 0x104c
    register_type: holding
    value_type: S_WORD
    unit_of_measurement: "˚C"
    device_class: temperature
    state_class: measurement
    accuracy_decimals: 2

  - platform: modbus_controller
    modbus_controller_id: bms0
    name: "${name} cell voltage 1"
    address: 34
    register_type: holding
    value_type: U_WORD
    unit_of_measurement: "V"
    state_class: measurement
    accuracy_decimals: 3
    filters:
      - multiply: 0.001

  - platform: modbus_controller
    modbus_controller_id: bms0
    name: "${name} cell voltage 2"
    address: 35
    register_type: holding
    value_type: U_WORD
    unit_of_measurement: "V"
    state_class: measurement
    accuracy_decimals: 3
    filters:
      - multiply: 0.001

  - platform: modbus_controller
    modbus_controller_id: bms0
    name: "${name} cell voltage 3"
    address: 36
    register_type: holding
    value_type: U_WORD
    unit_of_measurement: "V"
    state_class: measurement
    accuracy_decimals: 3
    filters:
      - multiply: 0.001

  - platform: modbus_controller
    modbus_controller_id: bms0
    name: "${name} cell voltage 4"
    address: 37
    register_type: holding
    value_type: U_WORD
    unit_of_measurement: "V"
    state_class: measurement
    accuracy_decimals: 3
    filters:
      - multiply: 0.001
  - platform: modbus_controller
    modbus_controller_id: bms0
    name: "${name} cell voltage 5"
    address: 38
    register_type: holding
    value_type: U_WORD
    unit_of_measurement: "V"
    state_class: measurement
    accuracy_decimals: 3
    filters:
      - multiply: 0.001

  - platform: modbus_controller
    modbus_controller_id: bms0
    name: "${name} cell voltage 6"
    address: 39
    register_type: holding
    value_type: U_WORD
    unit_of_measurement: "V"
    state_class: measurement
    accuracy_decimals: 3
    filters:
      - multiply: 0.001

  - platform: modbus_controller
    modbus_controller_id: bms0
    name: "${name} cell voltage 7"
    address: 40
    register_type: holding
    value_type: U_WORD
    unit_of_measurement: "V"
    state_class: measurement
    accuracy_decimals: 3
    filters:
      - multiply: 0.001

  - platform: modbus_controller
    modbus_controller_id: bms0
    name: "${name} cell voltage 8"
    address: 41
    register_type: holding
    value_type: U_WORD
    unit_of_measurement: "V"
    state_class: measurement
    accuracy_decimals: 3
    filters:
      - multiply: 0.001
  - platform: modbus_controller
    modbus_controller_id: bms0
    name: "${name} cell voltage 9"
    address: 42
    register_type: holding
    value_type: U_WORD
    unit_of_measurement: "V"
    state_class: measurement
    accuracy_decimals: 3
    filters:
      - multiply: 0.001

  - platform: modbus_controller
    modbus_controller_id: bms0
    name: "${name} cell voltage 10"
    address: 43
    register_type: holding
    value_type: U_WORD
    unit_of_measurement: "V"
    state_class: measurement
    accuracy_decimals: 3
    filters:
      - multiply: 0.001

  - platform: modbus_controller
    modbus_controller_id: bms0
    name: "${name} cell voltage 11"
    address: 44
    register_type: holding
    value_type: U_WORD
    unit_of_measurement: "V"
    state_class: measurement
    accuracy_decimals: 3
    filters:
      - multiply: 0.001

  - platform: modbus_controller
    modbus_controller_id: bms0
    name: "${name} cell voltage 12"
    address: 45
    register_type: holding
    value_type: U_WORD
    unit_of_measurement: "V"
    state_class: measurement
    accuracy_decimals: 3
    filters:
      - multiply: 0.001
  - platform: modbus_controller
    modbus_controller_id: bms0
    name: "${name} cell voltage 13"
    address: 46
    register_type: holding
    value_type: U_WORD
    unit_of_measurement: "V"
    state_class: measurement
    accuracy_decimals: 3
    filters:
      - multiply: 0.001

  - platform: modbus_controller
    modbus_controller_id: bms0
    name: "${name} cell voltage 14"
    address: 47
    register_type: holding
    value_type: U_WORD
    unit_of_measurement: "V"
    state_class: measurement
    accuracy_decimals: 3
    filters:
      - multiply: 0.001

  - platform: modbus_controller
    modbus_controller_id: bms0
    name: "${name} cell voltage 15"
    address: 48
    register_type: holding
    value_type: U_WORD
    unit_of_measurement: "V"
    state_class: measurement
    accuracy_decimals: 3
    filters:
      - multiply: 0.001

  - platform: modbus_controller
    modbus_controller_id: bms0
    name: "${name} discharge times"
    address: 67
    register_type: holding
    value_type: U_WORD
    accuracy_decimals: 0

  - platform: modbus_controller
    modbus_controller_id: bms0
    name: "${name} discharges"
    address: 69
    register_type: holding
    value_type: U_WORD
    accuracy_decimals: 0

  - platform: modbus_controller
    modbus_controller_id: bms0
    name: "${name} battery cycles"
    address: 0x1033
    register_type: holding
    value_type: U_WORD
    state_class: total_increasing
    accuracy_decimals: 0

  - platform: modbus_controller
    modbus_controller_id: bms0
    name: "${name} full battery capacity"
    address: 0x1032
    register_type: holding
    value_type: U_WORD
    unit_of_measurement: "Ah"
    device_class: current
    state_class: measurement
    accuracy_decimals: 2
    filters:
      - multiply: 0.01

  - platform: modbus_controller
    modbus_controller_id: bms0
    name: "${name} TCell1"
    address: 0x0012
    register_type: holding
    value_type: S_WORD
    unit_of_measurement: "˚C"
    device_class: temperature
    state_class: measurement
    accuracy_decimals: 2

  - platform: modbus_controller
    modbus_controller_id: bms0
    name: "${name} TCell2"
    address: 0x0013
    register_type: holding
    value_type: S_WORD
    unit_of_measurement: "˚C"
    device_class: temperature
    state_class: measurement
    accuracy_decimals: 2

  - platform: modbus_controller
    modbus_controller_id: bms0
    name: "${name} TCell3"
    address: 0x0014
    register_type: holding
    value_type: S_WORD
    unit_of_measurement: "˚C"
    device_class: temperature
    state_class: measurement
    accuracy_decimals: 2

  - platform: modbus_controller
    modbus_controller_id: bms0
    name: "${name} TCell4"
    address: 0x0015
    register_type: holding
    value_type: S_WORD
    unit_of_measurement: "˚C"
    device_class: temperature
    state_class: measurement
    accuracy_decimals: 2

  - platform: modbus_controller
    modbus_controller_id: bms0
    name: "${name} TCell5"
    address: 0x0016
    register_type: holding
    value_type: S_WORD
    unit_of_measurement: "˚C"
    device_class: temperature
    state_class: measurement
    accuracy_decimals: 2

  - platform: modbus_controller
    modbus_controller_id: bms0
    name: "${name} TCell6"
    address: 0x0017
    register_type: holding
    value_type: S_WORD
    unit_of_measurement: "˚C"
    device_class: temperature
    state_class: measurement
    accuracy_decimals: 2

  - platform: modbus_controller
    modbus_controller_id: bms0
    name: "${name} TCell7"
    address: 0x0018
    register_type: holding
    value_type: S_WORD
    unit_of_measurement: "˚C"
    device_class: temperature
    state_class: measurement
    accuracy_decimals: 2

  - platform: modbus_controller
    modbus_controller_id: bms0
    name: "${name} TCell8"
    address: 0x0019
    register_type: holding
    value_type: S_WORD
    unit_of_measurement: "˚C"
    device_class: temperature
    state_class: measurement
    accuracy_decimals: 2

  - platform: modbus_controller
    modbus_controller_id: bms0
    name: "${name} TCell9"
    address: 0x001A
    register_type: holding
    value_type: S_WORD
    unit_of_measurement: "˚C"
    device_class: temperature
    state_class: measurement
    accuracy_decimals: 2

  - platform: modbus_controller
    modbus_controller_id: bms0
    name: "${name} TCell10"
    address: 0x001B
    register_type: holding
    value_type: S_WORD
    unit_of_measurement: "˚C"
    device_class: temperature
    state_class: measurement
    accuracy_decimals: 2

  - platform: modbus_controller
    modbus_controller_id: bms0
    name: "${name} TCell11"
    address: 0x001C
    register_type: holding
    value_type: S_WORD
    unit_of_measurement: "˚C"
    device_class: temperature
    state_class: measurement
    accuracy_decimals: 2

  - platform: modbus_controller
    modbus_controller_id: bms0
    name: "${name} TCell12"
    address: 0x001D
    register_type: holding
    value_type: S_WORD
    unit_of_measurement: "˚C"
    device_class: temperature
    state_class: measurement
    accuracy_decimals: 2

  - platform: modbus_controller
    modbus_controller_id: bms0
    name: "${name} TCell13"
    address: 0x001E
    register_type: holding
    value_type: S_WORD
    unit_of_measurement: "˚C"
    device_class: temperature
    state_class: measurement
    accuracy_decimals: 2

  - platform: modbus_controller
    modbus_controller_id: bms0
    name: "${name} TCell14"
    address: 0x001F
    register_type: holding
    value_type: S_WORD
    unit_of_measurement: "˚C"
    device_class: temperature
    state_class: measurement
    accuracy_decimals: 2

  - platform: modbus_controller
    modbus_controller_id: bms0
    name: "${name} TCell15"
    address: 0x0020
    register_type: holding
    value_type: S_WORD
    unit_of_measurement: "˚C"
    device_class: temperature
    state_class: measurement
    accuracy_decimals: 2

  - platform: modbus_controller
    modbus_controller_id: bms0
    name: "${name} TCell16"
    address: 0x0021
    register_type: holding
    value_type: S_WORD
    unit_of_measurement: "˚C"
    device_class: temperature
    state_class: measurement
    accuracy_decimals: 2

  - platform: modbus_controller
    modbus_controller_id: bms0
    name: "${name} Number of Cells"
    address: 0x010f
    register_type: holding
    value_type: S_WORD
    accuracy_decimals: 1

  - platform: modbus_controller
    modbus_controller_id: bms0
    name: "${name} Depth of Discharge"
    address: 0x1015
    register_type: holding
    value_type: U_WORD
    unit_of_measurement: "%"
    accuracy_decimals: 0

  - platform: modbus_controller
    modbus_controller_id: bms0
    name: "${name} Ibus"
    address: 0x1016
    register_type: holding
    value_type: S_WORD
    unit_of_measurement: "A"
    accuracy_decimals: 0
    filters:
      - multiply: 0.01

  - platform: modbus_controller
    modbus_controller_id: bms0
    name: "${name} Ibat"
    address: 0x1016
    register_type: holding
    value_type: S_WORD
    unit_of_measurement: "I"
    accuracy_decimals: 0
    filters:
      - multiply: 0.01

text_sensor:
  - platform: modbus_controller
    address: 0x1016
    register_type: holding
    name: "${name} Mode Control"
    raw_encode: HEXBYTES
    lambda: |-
      uint16_t raw_value = modbus_controller::word_from_hex_str(x, 0);
      switch (raw_value) {
        case 0x0010:
          return std::string("Power Management");
        case 0x0303:
          return std::string("Battery Characteristic Discharge Mode");
        case 0x0505:
          return std::string("Maintenance");
        case 0x0606:
          return std::string("Production Test");
        case 0x0707:
          return std::string("Self-managed Constant Voltage Discharge");
        default:
          return std::string("Unknown Mode");
      }
      return x;
  - platform: modbus_controller
    address: 0x1037
    register_type: holding
    name: "${name} BMS Alarm Status 1"
    raw_encode: HEXBYTES
    lambda: |-
      uint16_t raw_value = modbus_controller::word_from_hex_str(x, 0);
      uint8_t hbyte = (raw_value >> 8) & 0xFF;  // High byte
      uint8_t lbyte = raw_value & 0xFF;         // Low byte

      std::vector<std::string> alarms;

      if (hbyte & 0x04) alarms.push_back("Cell voltage is too low");
      if (hbyte & 0x08) alarms.push_back("Voltage sampling disconnection");
      if (hbyte & 0x10) alarms.push_back("Charging MOS is damaged");
      if (hbyte & 0x20) alarms.push_back("Discharge MOS damage");
      if (hbyte & 0x40) alarms.push_back("Voltage sampling element is damaged");

      if (alarms.empty()) {
        return std::string("No alarms");
      } else {
        std::string result = "Alarms: ";
        for (size_t i = 0; i < alarms.size(); ++i) {
          result += alarms[i];
          if (i < alarms.size() - 1) {
            result += ", ";
          }
        }
        return result;
      }
      return x;

  - platform: modbus_controller
    address: 0x1038
    register_type: holding
    name: "${name} BMS Alarm Status 2"
    raw_encode: HEXBYTES
    lambda: |-
      uint16_t raw_value = modbus_controller::word_from_hex_str(x, 0);
      uint8_t hbyte = (raw_value >> 8) & 0xFF;  // High byte
      uint8_t lbyte = raw_value & 0xFF;         // Low byte

      std::vector<std::string> alarms;
      std::vector<std::string> states;

      // High byte alarms
      if (hbyte & 0x01) alarms.push_back("Discharge overtemperature protection");
      if (hbyte & 0x02) alarms.push_back("Discharge undertemperature protection");
      if (hbyte & 0x04) alarms.push_back("Overall Overvoltage Protection");
      if (hbyte & 0x08) alarms.push_back("Startup failed");

      // Charge MOS state
      states.push_back((hbyte & 0x10) ? "Charge MOS off" : "Charge MOS on");

      // Discharge MOS state
      states.push_back((hbyte & 0x20) ? "Discharge MOS off" : "Discharge MOS on");

      // Low byte alarms and states
      if (lbyte & 0x01) states.push_back("Charging");
      if (lbyte & 0x02) states.push_back("Discharging");
      if (lbyte & 0x04) alarms.push_back("Short circuit protection");
      if (lbyte & 0x10) alarms.push_back("Overvoltage protection (not resolved)");
      if (lbyte & 0x20) alarms.push_back("Undervoltage protection (not resolved)");
      if (lbyte & 0x40) alarms.push_back("Charging over temperature protection");
      if (lbyte & 0x80) alarms.push_back("Charging under temperature protection");

      std::string result;
      if (!states.empty()) {
        result += "States: ";
        for (size_t i = 0; i < states.size(); ++i) {
          result += states[i];
          if (i < states.size() - 1) {
            result += ", ";
          }
        }
      }

      if (!alarms.empty()) {
        if (!result.empty()) result += "; ";
        result += "Alarms: ";
        for (size_t i = 0; i < alarms.size(); ++i) {
          result += alarms[i];
          if (i < alarms.size() - 1) {
            result += ", ";
          }
        }
      }

      return result.empty() ? std::string("No alarms or notable states") : result;
  - platform: modbus_controller
    address: 0x1039
    register_type: holding
    name: "${name} BMS Alarm Status 3"
    raw_encode: HEXBYTES
    lambda: |-
      uint16_t raw_value = modbus_controller::word_from_hex_str(x, 0);
      uint8_t hbyte = (raw_value >> 8) & 0xFF;  // High byte
      uint8_t lbyte = raw_value & 0xFF;         // Low byte

      std::vector<std::string> alarms;
      std::vector<std::string> states;

      // High byte alarms and states
      if (hbyte & 0x01) alarms.push_back("Environmental low temperature protection");
      if (hbyte & 0x02) alarms.push_back("Environmental high temperature protection");
      if (hbyte & 0x80) states.push_back("Fan on");

      // Low byte alarms and states
      if (lbyte & 0x01) states.push_back("Force charging MOS on");
      if (lbyte & 0x02) states.push_back("Force charging MOS off");
      if (lbyte & 0x04) states.push_back("Forced discharge MOS on");
      if (lbyte & 0x08) states.push_back("Forced discharge MOS off");
      if (lbyte & 0x10) states.push_back("Heating pad on");
      if (lbyte & 0x20) alarms.push_back("MOSFET over temperature protection");
      if (lbyte & 0x40) alarms.push_back("MOSFET low temperature protection");
      if (lbyte & 0x80) alarms.push_back("Charging temperature too low");

      std::string result;
      if (!states.empty()) {
        result += "States: ";
        for (size_t i = 0; i < states.size(); ++i) {
          result += states[i];
          if (i < states.size() - 1) {
            result += ", ";
          }
        }
      }

      if (!alarms.empty()) {
        if (!result.empty()) result += "; ";
        result += "Alarms: ";
        for (size_t i = 0; i < alarms.size(); ++i) {
          result += alarms[i];
          if (i < alarms.size() - 1) {
            result += ", ";
          }
        }
      }

      return result.empty() ? std::string("No alarms or notable states") : result;
  - platform: modbus_controller
    address: 0x103c
    register_type: holding
    name: "${name} BMS Protection Status"
    raw_encode: HEXBYTES
    lambda: |-
      uint16_t raw_value = modbus_controller::word_from_hex_str(x, 0);
      uint8_t hbyte = (raw_value >> 8) & 0xFF;  // High byte
      uint8_t lbyte = raw_value & 0xFF;         // Low byte

      std::vector<std::string> protections;

      // High byte protections
      if (hbyte & 0x20) protections.push_back("Full charge protection");

      // Low byte protections
      if (lbyte & 0x01) protections.push_back("Cell overvoltage protection");
      if (lbyte & 0x02) protections.push_back("Overall overvoltage protection");
      if (lbyte & 0x04) protections.push_back("Cell undervoltage protection");
      if (lbyte & 0x08) protections.push_back("Overall undervoltage protection");
      if (lbyte & 0x10) protections.push_back("Charging overcurrent 1 protection");
      if (lbyte & 0x20) protections.push_back("Charging overcurrent 2 protection");
      if (lbyte & 0x40) protections.push_back("Discharge overcurrent 1 protection");
      if (lbyte & 0x80) protections.push_back("Discharge overcurrent 2 protection");

      if (protections.empty()) {
        return std::string("No active protections");
      } else {
        std::string result = "Active protections: ";
        for (size_t i = 0; i < protections.size(); ++i) {
          result += protections[i];
          if (i < protections.size() - 1) {
            result += ", ";
          }
        }
        return result;
      }
